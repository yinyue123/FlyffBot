# 形状检测工具 - 多方法检测系统 (test_shape.py)

## 功能概述

这是一个**多方法形状检测调试工具**，支持三种不同的检测算法，用于检测图像中的各种几何形状和物体。每种方法都有独立的参数调节界面，提供实时参数调整和多阶段可视化展示。

## 主要特性

✅ **三种检测方法**
  - 方法一：轮廓检测（检测各种几何形状）
  - 方法二：霍夫圆形检测（专门检测圆形）
  - 方法三：模板匹配检测（基于模板图像匹配）

✅ **启动时选择方法**
  - 程序启动时可选择使用哪种检测方法

✅ **独立参数界面**
  - 每种方法有不同的滑块参数
  - 实时调整参数，立即看到效果

✅ **改进的显示效果**
  - 更大的显示窗口（1600x900）
  - 更高的分辨率（600x400每个子图）
  - 2x2网格布局，清晰展示检测过程

✅ **优化的标注显示**
  - 半透明背景标签
  - 清晰的文字和颜色标记
  - 详细的检测信息

## 使用方法

### 基本用法

```bash
python test_shape.py
```

### 运行流程

1. **选择检测方法**
   ```
   请选择检测方法:
     1 - 方法一: 轮廓检测
     2 - 方法二: 霍夫圆形检测
     3 - 方法三: 模板匹配检测

   请输入方法编号 (1/2/3):
   ```

2. **输入图像路径**
   ```
   请输入图像路径: /path/to/your/image.jpg
   ```

3. **（仅方法三）输入模板目录**
   ```
   请输入模板图像目录路径: /path/to/templates/
   ```

4. **调整参数**
   - 使用滑块实时调整检测参数
   - 观察2x2网格中的检测过程
   - 每个方法有不同的参数选项

5. **保存结果**
   - 按 `s` 键保存当前检测结果
   - 按 `q` 或 `ESC` 退出程序

## 三种检测方法详解

### 方法一：轮廓检测

**适用场景**：检测各种几何形状（三角形、矩形、圆形、多边形等）

**检测流程**：
1. 灰度化
2. 去噪处理（可选多种算法）
3. 边缘检测（可选多种算法）
4. 查找轮廓
5. 轮廓近似
6. 根据顶点数判断形状

**可调参数**：

| 参数 | 范围 | 说明 |
|------|------|------|
| Blur Type | 0-3 | 去噪类型: 0=None, 1=Gaussian, 2=Median, 3=Bilateral |
| Kernel Size | 5-25 | 去噪核大小（奇数） |
| Edge Type | 0-3 | 边缘检测: 0=Canny, 1=Sobel, 2=Laplacian, 3=Scharr |
| Threshold1 | 50-255 | 边缘阈值1 |
| Threshold2 | 150-255 | 边缘阈值2 |
| Min Area | 500-10000 | 最小面积（过滤小轮廓） |
| Epsilon | 4-20 | 轮廓近似精度(%) |

**支持的形状类型**：
- 三角形（3个顶点）- 蓝色
- 正方形（4个顶点，宽高比≈1）- 黄色
- 矩形（4个顶点，宽高比≠1）- 青色
- 五边形（5个顶点）- 洋红
- 多边形（6-11个顶点）- 紫色
- 圆形（12+个顶点，圆度>0.8）- 绿色

**推荐配置**：
```
干净图像: Blur=None, Edge=Canny(50,150), MinArea=500, Epsilon=4
噪点图像: Blur=Median(7), Edge=Canny(60,180), MinArea=800, Epsilon=5
复杂细节: Blur=Bilateral(5), Edge=Canny(30,100), MinArea=300, Epsilon=2
```

### 方法二：霍夫圆形检测

**适用场景**：专门检测圆形或椭圆形物体

**检测流程**：
1. 灰度化
2. 高斯模糊
3. 霍夫圆变换检测
4. 筛选符合条件的圆

**可调参数**：

| 参数 | 范围 | 说明 |
|------|------|------|
| Blur Size | 5-25 | 模糊核大小 |
| DP | 1-3 | 累加器分辨率倒数 |
| Min Dist | 50-200 | 圆心之间最小距离 |
| Param1 | 100-300 | Canny边缘检测高阈值 |
| Param2 | 30-100 | 累加器阈值（越小检测越多） |
| Min Radius | 10-200 | 最小圆半径 |
| Max Radius | 100-500 | 最大圆半径 |

**优点**：
- 专门针对圆形优化
- 对噪声鲁棒性好
- 可以检测部分遮挡的圆

**推荐配置**：
```
标准圆形: Blur=5, DP=1, MinDist=50, Param1=100, Param2=30
小圆检测: MinRadius=10, MaxRadius=100
大圆检测: MinRadius=50, MaxRadius=500
```

### 方法三：模板匹配检测

**适用场景**：基于已知模板图像检测相似物体

**检测流程**：
1. 加载模板图像
2. 灰度化场景图和模板
3. 多尺度模板匹配
4. 阈值筛选
5. 非极大值抑制（去除重叠检测）

**可调参数**：

| 参数 | 范围 | 说明 |
|------|------|------|
| Method | 0-5 | 匹配方法: 0=CCOEFF_N, 1=CCORR_N, 2=SQDIFF_N |
| Threshold | 80-100 | 匹配阈值(%) |
| Scale Start | 80-150 | 起始缩放比例(%) |
| Scale End | 120-150 | 结束缩放比例(%) |
| Scale Step | 10-20 | 缩放步长(%) |

**匹配方法说明**：
- **CCOEFF_NORMED（推荐）**：相关系数匹配，归一化，对光照变化鲁棒
- **CCORR_NORMED**：互相关匹配，归一化
- **SQDIFF_NORMED**：平方差匹配，归一化（值越小越好）

**使用步骤**：
1. 准备模板图像：将要检测的物体图像保存到一个目录
2. 模板命名：文件名将作为检测标签（如 `circle.png` → "circle"）
3. 运行程序，选择方法3
4. 输入模板目录路径
5. 调整参数进行多尺度匹配

**推荐配置**：
```
精确匹配: Method=CCOEFF_N, Threshold=90, Scale=100-100
多尺度: Method=CCOEFF_N, Threshold=80, Scale=80-120, Step=10
旋转不变: 需要准备多个旋转角度的模板
```

## 显示界面说明

### 2x2网格布局

程序会显示一个2x2的网格，展示检测的不同阶段：

```
┌─────────────┬─────────────┐
│ 1. 灰度图   │ 2. 去噪后   │
├─────────────┼─────────────┤
│ 3. 边缘检测 │ 4. 检测结果 │
└─────────────┴─────────────┘
```

**各阶段说明**：
- **灰度图**：原始图像转换为灰度
- **去噪后**：应用去噪算法后的图像
- **边缘检测**：边缘检测结果（白色为边缘）
- **检测结果**：最终检测结果，用不同颜色标注

### 标注样式

每个检测到的形状都会用以下方式标注：
- **轮廓线**：用颜色绘制形状轮廓
- **顶点**：红色小圆点标记顶点
- **标签**：半透明黑色背景 + 彩色文字
- **信息**：形状名称 + 顶点数/半径/置信度

### 信息显示

屏幕左下角显示：
- 检测方法名称
- 处理时间（毫秒）
- 检测到的形状数量
- 快捷键提示

## 快捷键

- **q / ESC** - 退出程序
- **s** - 保存当前显示结果（PNG格式）

## 使用场景示例

### 场景1：检测几何图形

**需求**：检测图纸中的三角形、矩形、圆形

**方法选择**：方法一（轮廓检测）

**步骤**：
```bash
python test_shape.py
# 选择: 1
# 输入图像路径
# 调整参数:
#   Blur Type = 1 (Gaussian)
#   Kernel Size = 5
#   Edge Type = 0 (Canny)
#   Threshold1 = 50
#   Threshold2 = 150
#   Min Area = 500
#   Epsilon = 4
```

### 场景2：检测硬币或圆形物体

**需求**：在照片中检测圆形硬币

**方法选择**：方法二（霍夫圆形检测）

**步骤**：
```bash
python test_shape.py
# 选择: 2
# 输入图像路径
# 调整参数:
#   Blur Size = 5
#   DP = 1
#   Min Dist = 50
#   Param1 = 100
#   Param2 = 30
#   Min Radius = 20（根据硬币大小）
#   Max Radius = 100
```

### 场景3：检测特定物体（基于模板）

**需求**：在游戏截图中检测特定图标

**方法选择**：方法三（模板匹配）

**准备工作**：
1. 创建模板目录：`mkdir templates`
2. 截取图标保存为：`templates/icon1.png`, `templates/icon2.png`

**步骤**：
```bash
python test_shape.py
# 选择: 3
# 输入图像路径
# 输入模板目录: templates
# 调整参数:
#   Method = 0 (CCOEFF_NORMED)
#   Threshold = 80
#   Scale Start = 90
#   Scale End = 110
#   Scale Step = 10
```

## 三种方法对比

| 特性 | 方法一：轮廓检测 | 方法二：霍夫圆检测 | 方法三：模板匹配 |
|------|-----------------|-------------------|-----------------|
| **检测对象** | 各种几何形状 | 仅圆形 | 任意物体（需模板） |
| **速度** | 快 | 中等 | 较慢（多尺度） |
| **准确性** | 高（清晰图像） | 高（圆形） | 高（相似度） |
| **抗噪性** | 中等 | 好 | 中等 |
| **旋转不变** | 是 | 是 | 否（需多模板） |
| **尺度不变** | 否 | 否 | 是（多尺度匹配） |
| **需要模板** | 否 | 否 | 是 |
| **参数数量** | 7个 | 7个 | 5个 |
| **适用场景** | 几何图形识别 | 圆形物体检测 | 特定物体定位 |

**选择建议**：
- ✅ 检测几何形状（三角形、矩形等）→ **方法一**
- ✅ 专门检测圆形或球形物体 → **方法二**
- ✅ 检测特定的已知物体 → **方法三**
- ✅ 不知道检测什么形状 → 先试**方法一**

## 参数调优技巧

### 方法一调优流程

1. **先调边缘检测**
   - 观察"3. 边缘检测"窗口
   - 边缘应该清晰、连续、无断裂
   - 调整 Threshold1/Threshold2 直到满意

2. **再调去噪**
   - 如果边缘有噪点，增大 Kernel Size
   - 如果边缘断裂，减小 Kernel Size
   - 尝试不同的 Blur Type

3. **最后调形状参数**
   - Min Area：过滤太小的形状
   - Epsilon：控制轮廓简化程度
     - 顶点太多 → 增大 Epsilon
     - 顶点太少 → 减小 Epsilon

### 方法二调优流程

1. **调整圆半径范围**
   - 根据实际圆的大小设置 Min/Max Radius
   - 范围太大会检测到误报

2. **调整 Param2（重要）**
   - 值越小，检测到的圆越多（包括误报）
   - 值越大，检测越严格（可能漏检）
   - 推荐从30开始，逐步调整

3. **调整 Min Dist**
   - 如果圆很密集，减小此值
   - 如果检测到重复圆，增大此值

### 方法三调优流程

1. **选择合适的匹配方法**
   - 优先使用 CCOEFF_NORMED (0)
   - 如果效果不好，试试其他方法

2. **调整阈值**
   - Threshold 太高：漏检
   - Threshold 太低：误检
   - 推荐从80开始

3. **设置缩放范围**
   - 如果模板大小接近场景：Scale 95-105
   - 如果大小差异大：Scale 70-130
   - Scale Step 越小越精确，但越慢

## 常见问题

### Q1: 检测不到形状怎么办？

**方法一**：
- 检查"3. 边缘检测"窗口，边缘是否清晰
- 降低 Min Area
- 降低 Epsilon
- 尝试不同的边缘检测算法

**方法二**：
- 检查圆的半径是否在 Min/Max Radius 范围内
- 降低 Param2（但可能增加误报）
- 调整 Blur Size

**方法三**：
- 降低 Threshold
- 扩大 Scale 范围
- 检查模板是否和场景中的物体相似

### Q2: 检测到太多误报怎么办？

**方法一**：
- 增大 Min Area
- 增大 Epsilon（简化轮廓）
- 增强去噪（增大 Kernel Size）

**方法二**：
- 增大 Param2
- 增大 Min Dist
- 缩小半径范围

**方法三**：
- 增大 Threshold
- 减小 Scale 范围
- 使用更精确的模板

### Q3: 形状识别不准确（顶点数错误）

**原因**：Epsilon 参数不当

**解决方法**：
- 顶点太多 → 增大 Epsilon (5-8)
- 顶点太少 → 减小 Epsilon (2-3)
- 圆形被识别为多边形 → 减小 Epsilon

### Q4: 图像显示不够清晰

**已改进**：
- 显示窗口增大到 1600x900
- 每个子图分辨率 600x400
- 使用 WINDOW_NORMAL 可手动调整窗口

**建议**：
- 使用高分辨率的原始图像
- 全屏显示窗口
- 保存结果后用图像查看器打开

### Q5: 模板匹配找不到物体

**可能原因**：
1. 模板和场景差异太大（光照、角度、尺度）
2. Threshold 设置太高
3. Scale 范围不包含实际尺度

**解决方法**：
1. 使用更相似的模板
2. 降低 Threshold 到 70-80
3. 扩大 Scale 范围（如 50-150）
4. 准备多个角度的模板

### Q6: 程序运行很慢

**可能原因**：
- 图像分辨率太高
- 模板匹配的 Scale 范围太大

**优化方法**：
1. 缩小原始图像
2. 减小 Scale 范围
3. 增大 Scale Step
4. 减少模板数量

## 技术细节

### 轮廓检测原理

使用 Douglas-Peucker 算法进行轮廓近似：
```python
epsilon = epsilon_factor * perimeter
approx = cv2.approxPolyDP(contour, epsilon, True)
vertices = len(approx)
```

### 圆形判断

使用圆度公式：
```python
circularity = 4 * π * area / perimeter²
```
- 完美圆形：circularity = 1.0
- 程序阈值：circularity > 0.8

### 霍夫圆变换

基于霍夫梯度法（HOUGH_GRADIENT）：
1. Canny边缘检测
2. 梯度计算
3. 霍夫空间累加
4. 寻找局部最大值

### 模板匹配

支持6种匹配方法，推荐使用归一化相关系数：
```python
result = cv2.matchTemplate(image, template, cv2.TM_CCOEFF_NORMED)
```

### 非极大值抑制（NMS）

去除重叠的检测框：
1. 按置信度排序
2. 计算IoU（重叠度）
3. 抑制重叠度 > 0.5 的低分框

## 输出文件

按 `s` 键保存的文件格式：
```
shape_detection_YYYYMMDD_HHMMSS.png
```

包含完整的2x2网格显示，可直接用于：
- 报告文档
- 调试记录
- 参数对比

## 代码架构

```python
ShapeDetector (基类)
├── ContourShapeDetector (方法一)
├── HoughCircleDetector (方法二)
└── TemplateMatchDetector (方法三)

ShapeDetectorApp (应用程序)
├── select_method()
├── create_detector()
├── run_detector_with_trackbars()
└── _create_display()
```

**优点**：
- 面向对象设计
- 易于扩展新方法
- 每个检测器独立实现
- 统一的接口

## 扩展建议

### 添加新的检测方法

1. 继承 `ShapeDetector` 基类
2. 实现 `detect(**params)` 方法
3. 实现 `get_trackbar_names()` 方法
4. 在 `create_detector()` 中添加分支

示例：
```python
class CustomDetector(ShapeDetector):
    def __init__(self, image):
        super().__init__(image)
        self.method_name = "方法四：自定义检测"

    def detect(self, **params):
        # 实现检测逻辑
        shapes = []
        steps = {}
        return shapes, steps

    def get_trackbar_names(self):
        return [
            ('Param1', 10, 100, '参数1说明'),
        ]
```

### 添加新的形状分类

修改 `ContourShapeDetector._classify_shape()` 方法：
```python
elif vertices == 6:
    return "六边形", (255, 128, 0)
```

## 版本历史

- **v2.0** (2025-11-02) - 重大更新
  - ✅ 重构为多方法检测系统
  - ✅ 添加霍夫圆形检测方法
  - ✅ 添加模板匹配检测方法
  - ✅ 改进显示清晰度（1600x900窗口）
  - ✅ 优化标注显示（半透明背景）
  - ✅ 每种方法独立参数界面
  - ✅ 启动时选择检测方法

- **v1.0** (2025-11-02) - 初始版本
  - 单一轮廓检测方法
  - 基础参数调节

---

**作者**: Claude Code
**版本**: 2.0
**日期**: 2025-11-02
**许可**: MIT
